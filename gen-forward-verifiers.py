#! /usr/bin/python
#
# This simple script scans a simple c soure file that contains prototypes of
# functions to which a function and its actual arguments are passed in order to
# call them at some subsequent timepoint and generates simple C++-based variants
# of them that verify the correctness of the types at compile time.
#
# (c) 2018 by Sebastian Bauer
#
from __future__ import print_function

from pycparser import parse_file, c_ast, c_parser, c_generator
from pycparser.c_ast import FuncDecl

class FuncDefVisitor(c_ast.NodeVisitor):
  def visit_Decl(self, node):
    if isinstance(node.type, FuncDecl):
      param_list = node.type.args # type: ParamList
      args = [a[1] for a in param_list.children()]

      # We need at least three params: the function to call, the number of
      # the following paramters, and the ellipsis.
      if len(args) < 3:
        return

      if not isinstance(args[-1], c_ast.EllipsisParam):
        return

      return_type = node.type.type # type: Decl
      function = args[-3] # type: Decl
      argcount = args[-2] # type: Decl

      # Function must be a pointer to a function
      if not isinstance(function.type, c_ast.PtrDecl):
        return

      generator = c_generator.CGenerator()

      return_type_str = generator.visit(return_type) # type: str
      name_str = node.name # type: str

      # list of incoming arguments with types
      arg_strs = [] # type: List[str]

      # list of names of the arguments (without type)
      argnames_strs = [] # type: List[str]

      # Assume that the name of the functions that we are interested in end with
      # an underscore
      if not name_str.endswith('_'):
        return

      for a in args[:-3]:
        arg_strs.append(generator.visit(a))
        argnames_strs.append(a.name)

      arg_strs.append('R (*function)(A...)')
      arg_strs.append('int argcount')
      arg_strs.append('B... args')

      argnames_strs.append('(void *)function')
      argnames_strs.append('argcount')
      argnames_strs.append('args...')

      # First, generate code for the so-called C++2a standard (i.e., the
      # one that supports __VA_OPT__). The code will support the compile-time
      # verification of the argcount parameter and the type-correctness of the
      # args that should be supplied to the given function
      print('#if __cplusplus > 201703L')
      print('template<int N, typename R, typename... A, typename... B>')
      print('static inline {0} {1}({2})'.format(return_type_str, name_str + '2', ', '.join(arg_strs)))
      print('{')
      print('\tusing namespace simplemail;')
      print('\tstatic_assert(N == sizeof...(B));')
      print('\tstatic_assert(sizeof...(A) == sizeof...(B));')
      print('\tstatic_assert(is_convertible<tuple<A...>, tuple<B...>>::convertible == true);')
      print('\treturn {0}({1});'.format(name_str, ", ".join(argnames_strs)))
      print('}')
      print('#define {0}({1}, argcount, ...) \\'.format(name_str[:-1], ", ".join(argnames_strs[:-3] + ['function'])))
      print('\t{0}<argcount>({1}, argcount __VA_OPT__(,) __VA_ARGS__)'.format(name_str + '2', ", ".join(argnames_strs[:-3]+['function'])))

      # Second, code that works with at least a C++11 compiler. It lacks the
      # verification of the argcount parameter
      print('#elif __cplusplus >= 201103L')
      print('template<typename R, typename... A, typename... B>')
      print('static inline {0} {1}({2})'.format(return_type_str, name_str[:-1], ', '.join(arg_strs)))
      print('{')
      print('\tusing namespace simplemail;')
      print('\tstatic_assert(sizeof...(A) == sizeof...(B));')
      print('\tstatic_assert(is_convertible<tuple<A...>, tuple<B...>>::convertible == true);')
      print('\treturn {0}({1});'.format(name_str, ", ".join(argnames_strs)))
      print('}')
      # Finally, for all the remaining compilers
      print('#else')
      print('#define {0} {1}'.format(name_str[:-1], name_str))
      print('#endif')

if __name__ == '__main__':
  ast = parse_file('indep-include/subthreads.h', use_cpp=True, cpp_args=r'-I.')
  print("/* Autogenerated file */")
  v = FuncDefVisitor()
  v.visit(ast)
